<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Notion DB 실시간 세로 트리</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
  <style>
    :root {
      --bg: #0b1324; --panel: #101a33; --border: #23335b;
      --txt: #eaf0ff; --muted: #9fb2d9; --accent: #69d2ff; --accent2: #ffd166;
      --ok: #36d399; --warn: #f59e0b; --err: #f43f5e;
    }
    html, body { height: 100%; margin: 0; background: linear-gradient(180deg,#0b1324,#0f1b3a); color: var(--txt); font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", Arial; }
    header { position: sticky; top: 0; z-index: 5; padding: 14px 16px; border-bottom: 1px solid var(--border); background: rgba(16,26,51,.6); backdrop-filter: blur(6px); }
    h1 { font-size: 18px; margin: 0 0 8px 0; }
    .toolbar { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .tag { border: 1px solid var(--border); background: #0f1b33; border-radius: 999px; padding: 3px 8px; font-size: 12px; color: var(--muted); }
    .pill { font-size: 12px; padding: 3px 8px; border-radius: 999px; border: 1px solid var(--border); background: #0f1a36; color: #cfe3ff; }
    #msg { margin-top: 6px; font-size: 13px; color: var(--muted); }

    main { padding: 14px; display: grid; grid-template-columns: 380px 1fr; gap: 14px; }
    .panel { border: 1px solid var(--border); background: rgba(16,26,51,.55); border-radius: 14px; padding: 12px; box-shadow: 0 8px 24px rgba(0,0,0,.25); }
    .hint { font-size: 13px; color: #bdd3ff; line-height: 1.5; }
    .hint code { background: #0e1833; padding: 2px 5px; border-radius: 6px; border: 1px solid var(--border); color: #a9c7ff; }

    /* 트리 영역 */
    #treePanel { display: grid; grid-template-rows: auto 1fr; gap: 10px; }
    #treeContainer { min-height: 620px; height: 70vh; border: 1px solid var(--border); background: #0f1a36; border-radius: 12px; overflow: auto; position: relative; }
    #treeSvg { width: 100%; height: 100%; display: block; }

    .link { fill: none; stroke: #2a8cff; stroke-opacity: .6; stroke-width: 1.6px; }
    .link-root { stroke-opacity: .3; stroke-dasharray: 4 4; }
    .dep-link { fill: none; stroke: var(--accent2); stroke-width: 1.2px; stroke-dasharray: 5 4; opacity: .85; marker-end: url(#arrow-yellow); pointer-events: none; }

    .node rect { fill: #142652; stroke: #2753a3; stroke-width: 1.2px; rx: 7; ry: 7; }
    .node text { font-size: 12.5px; fill: #eef6ff; dominant-baseline: middle; paint-order: stroke; stroke: rgba(0,0,0,.25); stroke-width: 2px; }
    .node.done { opacity: .35; } /* Done 체크 시 반투명 처리 */
    .legend { position: absolute; right: 10px; top: 10px; font-size: 12px; color: var(--muted); background: rgba(0,0,0,.25); border: 1px solid var(--border); padding: 6px 8px; border-radius: 9px; }

    /* 중첩/오버랩 방지: 충분한 세로 간격 + 노드 간 분리도 강화 */
    .node rect, .node text { pointer-events: none; } /* 드래그/선택으로 겹침 방지 */
  </style>
</head>
<body>
  <header>
    <h1>Notion DB 실시간 세로 트리</h1>
    <div class="toolbar">
      <span class="tag" id="conn">SSE: 연결중...</span>
      <span class="tag" id="last">갱신: -</span>
      <span class="tag">Done 체크 항목은 반투명 처리</span>
    </div>
    <div id="msg"></div>
  </header>

  <main>
    <section class="panel">
      <div class="hint">
        <div style="margin-bottom:8px;"><b>설명</b></div>
        • 이 화면은 <b>노션 데이터베이스</b>만을 읽어 <b>즉시 트리</b>로 보여줍니다.<br/>
        • 노션에서 <code>item name</code>(제목), <code>upper</code>(부모 이름), <code>dependency</code>(쉼표 구분), <code>level</code>(숫자), 날짜들(<code>early/late</code>), <code>Done</code>(체크박스)을 사용하세요.<br/>
        • 노션에서 수정하면 웹훅 → 서버 → 브라우저 <b>SSE</b>로 전달되어 <b>자동 갱신</b>됩니다(일부 이벤트는 최대 약 1분 지연).<br/>
      </div>
    </section>

    <section id="treePanel" class="panel">
      <div class="legend">━ 구조(upper) / ⋯⋯ <span style="color:#ffd166">의존(dependency)</span></div>
      <div id="treeContainer">
        <svg id="treeSvg" aria-label="세로 트리(노션)"></svg>
      </div>
    </section>
  </main>

  <script>
    const $ = s => document.querySelector(s);
    const msg = (t, tone="info") => {
      const el = $("#msg");
      el.textContent = t || "";
      el.style.color = tone === "ok" ? "var(--ok)" : tone === "warn" ? "var(--warn)" :
                       tone === "err" ? "var(--err)" : "var(--muted)";
    };

    // 데이터 가져오기
    async function fetchItems() {
      const r = await fetch('/api/items', { headers: { 'Accept': 'application/json' } });
      if (!r.ok) throw new Error('items fetch failed');
      const { items } = await r.json();
      return items || [];
    }

    // UI 갱신
    async function reload() {
      try {
        msg('노션에서 데이터 불러오는 중...');
        const items = await fetchItems();
        renderTree(items);
        const t = new Date();
        $("#last").textContent = `갱신: ${t.toLocaleString()}`;
        msg('갱신 완료', 'ok');
      } catch (e) {
        console.error(e);
        msg('데이터 갱신 실패', 'err');
      }
    }

    // 트리 렌더링
    function renderTree(items) {
      const svg = d3.select("#treeSvg");
      const container = $("#treeContainer");
      svg.selectAll("*").remove();

      // name 세트
      const names = new Set(items.map(x => x.name).filter(Boolean));

      // 루트 노드 + 아이템
      const nodes = [{ name: "ROOT", _root: true }];
      for (const it of items) {
        const parent = it.upper && names.has(it.upper) ? it.upper : "ROOT";
        nodes.push({ ...it, upperNormalized: parent });
      }

      // 데이터가 없을 때
      if (nodes.length === 1) {
        svg.append("text").attr("x", 20).attr("y", 28)
          .text("표시할 데이터가 없습니다. 노션 DB에 행을 추가하세요.")
          .attr("fill", "#96a5c6").attr("font-size", 13);
        return;
      }

      // 계층화
      const stratify = d3.stratify().id(d => d.name).parentId(d => d._root ? null : d.upperNormalized);
      let root = stratify(nodes);

      // 레이아웃: 세로 트리, 충분한 간격으로 오버랩 방지
      const depthH = 180; // 가로(깊이) 간격
      const tree = d3.tree()
        .nodeSize([38, depthH])                       // 세로 간격 38px로 넉넉히
        .separation((a,b) => (a.parent === b.parent ? 1.25 : 1.5));
      tree(root);

      // 좌표 보정 & viewBox 계산
      const xs = root.descendants().map(d => d.x);
      const minX = Math.min(...xs);
      const shiftX = 32 - minX;
      root.each(d => { d.x += shiftX; d.y = d.depth * depthH + 50; });

      const maxX = d3.max(root.descendants(), d => d.x) || 600;
      const maxY = d3.max(root.descendants(), d => d.y) || 800;
      const pad = 80;
      const width = Math.max(container.clientWidth, maxY + pad);
      const height = Math.max(container.clientHeight, maxX + pad);
      svg.attr("viewBox", [0, 0, width, height].join(" "));

      // defs: 의존 화살표
      const defs = svg.append("defs");
      defs.append("marker")
        .attr("id", "arrow-yellow")
        .attr("viewBox", "0 0 10 10")
        .attr("refX", 10).attr("refY", 5)
        .attr("markerWidth", 6).attr("markerHeight", 6)
        .attr("orient", "auto-start-reverse")
        .append("path").attr("d","M 0 0 L 10 5 L 0 10 z").attr("fill","#ffd166");

      const g = svg.append("g");

      // 구조 링크 먼저(뒤쪽 레이어)
      const linkGen = d3.linkVertical().x(d => d.x).y(d => d.y);
      g.append("g").selectAll("path")
        .data(root.links())
        .join("path")
        .attr("class", d => d.source.data.name === "ROOT" ? "link link-root" : "link")
        .attr("d", linkGen);

      // 노드
      const nodeSel = g.append("g").selectAll("g.node")
        .data(root.descendants().filter(d => d.data.name !== "ROOT"))
        .join("g")
        .attr("class", d => `node${d.data.done ? ' done' : ''}`)
        .attr("transform", d => `translate(${d.x},${d.y})`);

      // 라벨 먼저(크기 측정)
      const padX = 10, padY = 6;
      const labels = nodeSel.append("text")
        .text(d => d.data.name)
        .attr("text-anchor", "start")
        .attr("x", padX).attr("y", 0);

      // bbox로 박스 크기 맞춤
      nodeSel.each(function(d) {
        const bbox = this.querySelector("text").getBBox();
        const w = Math.max(68, bbox.width + padX * 2);
        const h = bbox.height + padY * 2;
        d3.select(this).insert("rect", "text")
          .attr("x", 0).attr("y", -h/2).attr("width", w).attr("height", h);
        const tip = [
          `name: ${d.data.name}`,
          d.data.level != null ? `level: ${d.data.level}` : null,
          d.data.upper ? `upper: ${d.data.upper}` : null,
          d.data.dependency ? `dependency: ${d.data.dependency}` : null,
          d.data.early_start ? `early start: ${d.data.early_start}` : null,
          d.data.late_start ? `late start: ${d.data.late_start}` : null,
          d.data.early_finish ? `early finish: ${d.data.early_finish}` : null,
          d.data.late_finish ? `late finish: ${d.data.late_finish}` : null,
          d.data.done ? `Done: ✅` : null
        ].filter(Boolean).join("\n");
        d3.select(this).append("title").text(tip);
      });

      // 의존 링크(점선) - 노드 레이어 위로 겹치지 않도록 곡선/마커 사용 + pointer-events none
      const pos = new Map();
      root.descendants().forEach(n => { if (n.data && n.data.name) pos.set(n.data.name, {x:n.x, y:n.y}); });
      const depEdges = [];
      for (const it of items) {
        if (!it.dependency) continue;
        const arr = String(it.dependency).split(",").map(s => s.trim()).filter(Boolean);
        for (const dep of arr) {
          if (pos.has(dep) && pos.has(it.name)) {
            const s = pos.get(dep), t = pos.get(it.name);
            depEdges.push({ s, t, from: dep, to: it.name });
          }
        }
      }
      g.append("g").selectAll("path.dep-link")
        .data(depEdges)
        .join("path")
        .attr("class", "dep-link")
        .attr("d", d => {
          const mx = (d.s.x + d.t.x)/2;
          return `M ${d.s.x} ${d.s.y} C ${mx} ${d.s.y}, ${mx} ${d.t.y}, ${d.t.x} ${d.t.y}`;
        })
        .append("title").text(d => `dependency: ${d.from} → ${d.to}`);
    }

    // SSE 연결
    function connectSSE() {
      const es = new EventSource('/api/stream', { withCredentials: false });
      es.addEventListener('hello', () => { $("#conn").textContent = 'SSE: 연결됨'; });
      es.addEventListener('ping', () => { /* keepalive */ });
      es.addEventListener('reload', () => { reload(); });
      es.onerror = () => { $("#conn").textContent = 'SSE: 재연결 시도중...'; };
      return es;
    }

    // 최초 구동
    (async () => {
      connectSSE();
      await reload(); // 초기 1회 로드
      // 만약 웹훅 설정 전이라면 안전망으로 60초 폴링
      setInterval(() => reload(), 60000);
    })();
  </script>
</body>
</html>
